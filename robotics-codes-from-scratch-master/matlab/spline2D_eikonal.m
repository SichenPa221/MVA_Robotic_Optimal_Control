function spline2D_eikonal
%% Gauss-Newton optimization of an SDF encoded with concatenated cubic polysplines, 
%% by considering unit norm derivatives in the cost function.
%% In this example, the points used for training are only on the zero-level set (contours of the shape).
%%
%% Copyright (c) 2023 Idiap Research Institute <https://www.idiap.ch/>
%% Written by Sylvain Calinon <https://calinon.ch>
%% 
%% This file is part of RCFS <https://robotics-codes-from-scratch.github.io/>
%% License: MIT


%% Parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
param.nbFct = 4; %Number of basis functions for each dimension 
param.nbSeg = 4; %Number of segments for each dimension 
param.nbIn = 2; %Dimension of input data (here: 2D surface embedded in 3D)
param.nbOut = 1; %Dimension of output data (here: height data)
param.nbDim = 40; %Grid size for each dimension (same as sdf01.mat)
param.nbIter = 100; %Maximum number of iterations for Gauss-Newton optimization
param.qt = 1E0; %Tracking weight for Gauss-Newton optimization
param.qn = 1E-4; %Norm weight for Gauss-Newton optimization

%Input array
[T1, T2] = meshgrid(linspace(0,1,param.nbDim));

%Points to be used for the eikonal cost
%id_eikonal = [[1:param.nbDim], param.nbDim^2-[0:param.nbDim-1], [0:param.nbDim-1]*param.nbDim+1, [1:param.nbDim]*param.nbDim]; %Points on the borders

%id_eikonal = ceil(rand(1,400) * (param.nbDim^2-1)); %Points randomly distributed

st = 3;
idTmp = 1:st:param.nbDim;
id_eikonal = idTmp' + (idTmp - 1) * param.nbDim; %Points uniformly distributed
id_eikonal = id_eikonal(:)';
T_eikonal = [T1(id_eikonal); T2(id_eikonal)];

%Prior surface (SDF generated by demo_SDF01.m)
load('../data/sdf_circle01.mat');
x00 = y';

%Reference surface (SDF generated by demo_SDF01.m)
load('../data/sdf01.mat');
ox0 = y';
dx0 = dx;


%% Precomputation of Bézier curve in matrix form (as in https://youtu.be/jvPPXbo87ds?t=434 or https://dergipark.org.tr/en/download/article-file/1633884)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Bézier curve (as in https://youtu.be/jvPPXbo87ds?t=434 or https://dergipark.org.tr/en/download/article-file/1633884)
param.B0 = zeros(param.nbFct); %Polynomial coefficients matrix
for n=1:param.nbFct
	for i=1:param.nbFct
		param.B0(param.nbFct-i+1,n) = (-1)^(param.nbFct-i-n) * -binomial(param.nbFct-1, i-1) * binomial((param.nbFct-1)-(i-1), (param.nbFct-1)-(n-1)-(i-1));
	end
end
%Matrices for a concatenation of curves
param.B = kron(eye(param.nbSeg), param.B0);

%Bézier curve constraint: Last control point and first control point of next segment should be the same (w4-w5=0, ...), 
%and the two control points around should be symmetric (w3-2*w5+w6=0, ...),see https://youtu.be/jvPPXbo87ds?t=1188
param.C0 = blkdiag(eye(param.nbFct-4), [[1; 0; 0; -1], [0; 1; 1; 2]]); %w4=w5 and w6=-w3+2*w5
param.C = eye(2);
for n=1:param.nbSeg-1
	param.C = blkdiag(param.C, param.C0);
end
param.C = blkdiag(param.C, eye(param.nbFct-2));

param.BC = param.B * param.C;
param.M = kron(param.B * param.C, param.B * param.C); %Resulting transformation matrix


%% Encoding with basis functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nbT = param.nbDim / param.nbSeg; %Number of elements for each dimension of the grid
t = linspace(0, 1-1/nbT, nbT); %Grid range for each dimension
[param.Psi_all, param.dPsi_all] = computePsiGridFast(t, param);

%Keep rows corresponding to the points used for the eikonal cost
%param.Psi_eikonal = param.Psi_all(id_eikonal,:,:);
param.dPsi_eikonal = param.dPsi_all(id_eikonal,:,:);


%% Generate training data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
w0 = param.Psi_all \ x00; %Weights for prior SDF

w_all = param.Psi_all \ x0;
x_all = param.Psi_all * w_all; %SDF reference

dx(1,:) = param.dPsi_all(:,:,1) * w_all;
dx(2,:) = param.dPsi_all(:,:,2) * w_all;

h = figure('position',[10 10 2600 1000]); 
msh = contour(T1, T2, reshape(x_all, [param.nbDim, param.nbDim]), [0.0, 0.0]);
T_contour = msh(:,2:end);
%T = size(T_contour,2);

%Compute distances and derivatives at the desired points 
[param.Psi_contour, param.dPsi_contour] = computePsiList(T_contour, param);
x_contour = param.Psi_contour * w_all;
dxmat(1,:) = param.dPsi_contour(:,:,1) * w_all;
dxmat(2,:) = param.dPsi_contour(:,:,2) * w_all;

%%Compute distances and derivatives at the desired points using the raw discrete data
%t12 = [T1(:)'; T2(:)'];
%for t=1:T
%	etmp = t12 - repmat(T_contour(:,t), 1, size(t12,2));
%	[~,id] = min(etmp(1,:).^2+etmp(2,:).^2); %Find closest point on precomputed grid
%	x_contour(1,t) = x(id); 
%	dx_contour(:,t) = dx(:,id);
%end


%% Batch estimation using distances 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
wb_contour = param.Psi_contour \ x_contour; 
xb = param.Psi_all * wb_contour;
param.Mu = param.Psi_contour * wb_contour; %SDF reference

%Reconstruction of derivatives
dxb(1,:) = param.dPsi_all(:,:,1) * wb_contour;
dxb(2,:) = param.dPsi_all(:,:,2) * wb_contour;
Jbn = sum(dxb.^2); %Squared norm of gradients


%% Gauss-Newton estimation using distances and unit norm derivatives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
w = w0;
%w = zeros(size(w_all));
%w = wb_contour + randn(size(wb_contour)) * 1E-10; %Initialization
for n=1:param.nbIter
	[ft, Jt] = f_track(w, param); %Residual and Jacobian for SDF match objective
	[fn, Jn] = f_norm(w, param); %Residual and Jacobian for unit norm objective
	dw = (Jt'*Jt * param.qt + Jn'*Jn * param.qn + eye(size(Jn,2))*1E-12) \ (-Jt' * ft * param.qt - Jn' * fn * param.qn); %Gauss-Newton update
	
	%Estimate step size with backtracking line search method
	alpha = 1;
	cost0 = ft' * ft * param.qt + fn' * fn * param.qn; %Cost
	while 1
		w_tmp = w + dw * alpha;
		ft_tmp = f_track(w_tmp, param); %Residual for SDF match objective
		fn_tmp = f_norm(w_tmp, param); %Residual for unit norm objective
		cost = ft_tmp' * ft_tmp * param.qt + fn_tmp' * fn_tmp * param.qn; %Cost
		if cost < cost0 || alpha < 1E-3
			break;
		end
		alpha = alpha * 0.5;
	end	
	w = w + dw * alpha; %Gauss-Newton update step
	
	if norm(dw * alpha) < 1E-3
		break; %Stop optimization when solution is reached
	end
end
disp(['iLQR converged in ' num2str(n) ' iterations. Cost: ' num2str(cost)]);

x = param.Psi_all * w; %Reconstruction of SDF

%Reconstruction of derivatives
dx(1,:) = param.dPsi_all(:,:,1) * w;
dx(2,:) = param.dPsi_all(:,:,2) * w;
Jn = sum(dx.^2); %Squared norm of gradients



%% Plot evolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
colormap(repmat(linspace(1,.4,64),3,1)');

%Solution with cost on matching SDF reference
subplot(1,2,1); hold on; axis off; 

title('Without eikonal cost','fontsize',30);
%title(['Cost on matching SDF reference (cost on unit norm: ' num2str(sum((Jbn-1).^2)) ')'],'fontsize',30);
%Reconstructed surface
%surface(T1, T2, reshape(xb, [param.nbDim, param.nbDim])-max(xb), 'FaceColor','interp','EdgeColor','interp'); %SDF
surface(T1, T2, reshape(Jbn, [param.nbDim, param.nbDim])-max(Jbn), 'FaceColor','interp','EdgeColor','interp');
contour(T1, T2, reshape(xb, [param.nbDim, param.nbDim]), [-1:.02:1], 'linewidth',2); %'color',[0 0 0]
%Zero contours (boundaries of object)
msh = contour(T1, T2, reshape(xb, [param.nbDim, param.nbDim]), [0, 0]);
%plot(msh(1,2:end), msh(2,2:end), '-','linewidth',4,'color',[0 0 .8]);
id = 1;
while id<size(msh,2)
	n = msh(2,id);
	plot(msh(1,id+1:id+n), msh(2,id+1:id+n), '-','linewidth',4,'color',[0 0 .8]);
	id = id + n + 1;
end
%Observed points
plot(T_contour(1,:), T_contour(2,:), '.','markersize',22,'color',[.8,0,0]);
axis tight; axis equal; axis([0 1 0 1]); axis ij; 
set(gca,'position',[0 0 .5 .9]);
%sub_pos = get(gca,'position'); % get subplot axis position
%set(gca,'position',sub_pos.*[1 1 1.2 1.2]) % stretch its width and height


%Solution with cost on matching SDF reference and unit norm derivatives
subplot(1,2,2); hold on; axis off; 
title('With eikonal cost','fontsize',30);
%title(['Cost on matching SDF reference and unit norm derivatives (cost on unit norm: ' num2str(sum((Jn-1).^2)) ')'],'fontsize',30);
%Reconstructed surface
%surface(T1, T2, reshape(x, [param.nbDim, param.nbDim])-max(x), 'FaceColor','interp','EdgeColor','interp'); %SDF
surface(T1, T2, reshape(Jn, [param.nbDim, param.nbDim])-max(Jn), 'FaceColor','interp','EdgeColor','interp');
contour(T1, T2, reshape(x, [param.nbDim, param.nbDim]), [-1:.02:1], 'linewidth',2); %'color',[0 0 0]
%Zero contours (boundaries of object)
msh = contour(T1, T2, reshape(x, [param.nbDim, param.nbDim]), [0, 0]);
%plot(msh(1,2:end), msh(2,2:end), '-','linewidth',4,'color',[0 0 .8]);
id = 1;
while id<size(msh,2)
	n = msh(2,id);
	plot(msh(1,id+1:id+n), msh(2,id+1:id+n), '-','linewidth',4,'color',[0 0 .8]);
	id = id + n + 1;
end
%plot(T1, T2, '.','markersize',8,'color',[.8,.4,0]);
%Eikonal points
plot(T_eikonal(1,:), T_eikonal(2,:), '.','markersize',25,'color',[0,.6,0]);

%Observed points
plot(T_contour(1,:), T_contour(2,:), '.','markersize',25,'color',[.8,0,0]);
axis tight; axis equal; axis([0 1 0 1]); axis ij;
set(gca,'position',[.4 0 .5 .9]);

%size(T_eikonal)
%size(T_contour)

%print('-dpng','graphs/spline2D_unitGradientNorm01.png');
waitfor(h);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Residual and Jacobian for tracking objective
function [f, J] = f_track(w, param)
	f = param.Psi_contour * w - param.Mu; %residual
	J = param.Psi_contour; %Jacobian
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Residual and Jacobian for unit norm objective (for points on the whole workspace)
%function [f, J] = f_norm(w, param)
%	dx(1,:) = param.dPsi_all(:,:,1) * w;
%	dx(2,:) = param.dPsi_all(:,:,2) * w;
%	
%	%Fast version
%	dxn = sum(dx.^2)'; %norm
%	f = dxn - 1; %residual
%	M = kron(ones(1,size(dx,2)), dx') .* kron(eye(size(dx,2)), ones(1,2));
%	J = 2 * M * reshape([param.dPsi_all(:,:,1), param.dPsi_all(:,:,2)]', [size(w,1),size(dx,2)*2])'; %Jacobian
%	
%%	%Slow version
%%	f = [];
%%	J = [];
%%	for t=1:size(dx,2)
%%		ftmp = dx(:,t)' * dx(:,t) - 1;
%%		Jtmp = 2 * dx(:,t)' * squeeze(param.dPsi_all(t,:,:))';
%%		f = [f; ftmp];
%%		J = [J; Jtmp];
%%	end
%end

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Residual and Jacobian for unit norm objective (for a selection of points used for the eikonal cost)
function [f, J] = f_norm(w, param)
	dx(1,:) = param.dPsi_eikonal(:,:,1) * w;
	dx(2,:) = param.dPsi_eikonal(:,:,2) * w;
	
	%Fast version
	dxn = sum(dx.^2)'; %norm
	f = dxn - 1; %residual
	M = kron(ones(1,size(dx,2)), dx') .* kron(eye(size(dx,2)), ones(1,2));
	J = 2 * M * reshape([param.dPsi_eikonal(:,:,1), param.dPsi_eikonal(:,:,2)]', [size(w,1),size(dx,2)*2])'; %Jacobian
	
%	%Slow version
%	f = [];
%	J = [];
%	for t=1:size(dx,2)
%		ftmp = dx(:,t)' * dx(:,t) - 1;
%		Jtmp = 2 * dx(:,t)' * squeeze(param.dPsi_eikonal(t,:,:))';
%		f = [f; ftmp];
%		J = [J; Jtmp];
%	end
end

%%%%%%%%%%%%%%%%
function b = binomial(n, i)
	if n>=0 && i>=0
		b = factorial(n) / (factorial(i) * factorial(n-i));
	else
		b = 0;
	end
end

%%%%%%%%%%%%%%%%
function [Psi, dPsi] = computePsiGridFast(t, param)
	%Time parameters matrix to compute positions
	T0 = zeros(size(t,2), param.nbFct); 
	for n=1:param.nbFct
		T0(:,n) = t.^(n-1);
	end
	%Matrices for a concatenation of curves
	T = kron(eye(param.nbSeg), T0);

	%Derivatives
	%Time parameters matrix to compute derivatives
	dT0 = zeros(size(t,2), param.nbFct); 
	for n=2:param.nbFct
		dT0(:,n) = (n-1) * t.^(n-2) * param.nbSeg; %Warning: n=1 creates 0/0
	end
%	dT0 = zeros(size(t,2), param.nbFct); 
%	for n=1:param.nbFct-1
%		dT0(:,n+1) = n * t.^(n-1);
%	end
	%Matrices for a concatenation of curves
	dT = kron(eye(param.nbSeg), dT0);
	
	%Second derivatives (to compute Hessians analytically)
	ddT0 = zeros(size(t,2), param.nbFct); 
	for n=3:param.nbFct
		ddT0(:,n) = (n-1) * (n-2) * t.^(n-3) * param.nbSeg^2;
	end
%	ddT0 = zeros(size(t,2), param.nbFct); 
%	for n=1:param.nbFct-2
%		ddT0(:,n+2) = n * (n-1) * t.^(n-2);
%	end
	%Matrices for a concatenation of curves
	ddT = kron(eye(param.nbSeg), ddT0);

	%Transform to multidimensional basis functions
	%Psi = kron(s(1).phi, s(2).phi); %Surface primitive
	Psi = kron(T, T) * param.M; %Surface primitive

	%Transform to multidimensional basis functions
	%dPsi1 = kron(s(1).dphi, s(2).phi);
	%dPsi2 = kron(s(1).phi, s(2).dphi); 
	dPsi(:,:,1) = kron(dT, T) * param.M; %Computation leveraging Kronecker properties
	dPsi(:,:,2) = kron(T, dT) * param.M; %Computation leveraging Kronecker properties
end


%%%%%%%%%%%%%%%%
%Fast version
function [Psi, dPsi] = computePsiList(Tmat, param)
	Psi = [];
	dPsi1 = [];
	dPsi2 = [];
	%Compute Psi for each point
	for k=1:size(Tmat,2)
		T = zeros(size(Tmat,1), param.nbFct);
		dT = zeros(size(Tmat,1), param.nbFct); 
		%Compute Psi for each dimension
		for d=1:size(Tmat,1)
			tt = mod(Tmat(d,k), 1/param.nbSeg) * param.nbSeg; %Compute residual within the segment in which the point falls
			id = round(Tmat(d,k) * param.nbSeg - tt); %Determine in which segment the point falls in order to evaluate the basis function accordingly
			%Handle inputs beyond lower bound
			if id < 0
				tt = tt + id;
				id = 0;
			end
			%Handle inputs beyond upper bound
			if id > (param.nbSeg-1)
				tt = tt + id - (param.nbSeg-1);
				id = param.nbSeg-1;
			end
			%Evaluate polynomials
			T(d,:) = tt.^[0:param.nbFct-1];
			dT(d,2:end) = [1:param.nbFct-1] .* tt.^[0:param.nbFct-2] * param.nbSeg;
			idl(:,d) = id*param.nbFct + [1:param.nbFct];
		end
		%Reconstruct Psi for all dimensions
		Mtmp = kron(param.BC(idl(:,1),:), param.BC(idl(:,2),:)); %Resulting transformation matrix		
		Psi = [Psi; kron(T(1,:), T(2,:)) * Mtmp]; %Surface primitive
		dPsi1 = [dPsi1; kron(dT(1,:), T(2,:)) * Mtmp]; %Computation leveraging Kronecker properties
		dPsi2 = [dPsi2; kron(T(1,:), dT(2,:)) * Mtmp]; %Computation leveraging Kronecker properties
	end	
	dPsi(:,:,1) = dPsi1;
	dPsi(:,:,2) = dPsi2;
end

