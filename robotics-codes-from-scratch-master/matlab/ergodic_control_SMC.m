function ergodic_control_SMC
%% 2D ergodic control formulated as Spectral Multiscale Coverage (SMC) objective,
%% with a spatial distribution described as a mixture of Gaussians.
%% 
%% Copyright (c) 2023 Idiap Research Institute <https://www.idiap.ch>
%% Written by Sylvain Calinon <https://calinon.ch>
%% 
%% This file is part of RCFS <https://rcfs.ch>
%% License: MIT


%% Parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nbData = 200; %Number of datapoints
nbFct = 10; %Number of basis functions along x and y
nbVar = 2; %Dimension of datapoint
nbGaussian = 2; %Number of Gaussians to represent the spatial distribution
nbRes = 100;
sp = (nbVar + 1) / 2; %Sobolev norm parameter
dt = 1E-2; %Time step
xlim = [0; 1]; %Domain limit for each dimension (considered to be 1 for each dimension in this implementation)
L = (xlim(2) - xlim(1)) * 2; %Size of [-xlim(2),xlim(2)]
om = 2 * pi / L; %om parameter
u_max = 1E1; %Maximum speed allowed 

%Desired spatial distribution represented as a mixture of Gaussians (GMM)
Mu(:,1) = [.5; .7]; 
Sigma(:,:,1) = [.3;.1]*[.3;.1]' *5E-1 + eye(nbVar)*5E-3; %eye(nbVar).*1E-2; 
Mu(:,2) =  [.6; .3]; 
Sigma(:,:,2) = [.1;.2]*[.1;.2]' *3E-1 + eye(nbVar)*1E-2;

Alpha = ones(1,nbGaussian) / nbGaussian; %Mixing coefficients


%% Compute Fourier series coefficients phi_k of desired spatial distribution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rg = 0:nbFct-1;
[KX(1,:,:), KX(2,:,:)] = ndgrid(rg, rg);
Lambda = (KX(1,:).^2 + KX(2,:).^2 + 1)'.^-sp; %Weighting vector (Eq.(15))

%Explicit computation of w_hat by exploiting the Fourier transform properties of Gaussians (optimized version by exploiting symmetries),
%by enumerating symmetry operations for 2D signal ([-1,-1],[-1,1],[1,-1] and [1,1]), and removing redundant ones -> keeping ([-1,-1],[-1,1])
op = hadamard(2^(nbVar-1));
op = op(1:nbVar,:);
%Compute w_hat
kk = KX(:,:) * om;
w_hat = zeros(nbFct^nbVar, 1);
for j=1:nbGaussian
	for n=1:size(op,2)
		MuTmp = diag(op(:,n)) * Mu(:,j); %Eq.(20)
		SigmaTmp = diag(op(:,n)) * Sigma(:,:,j) * diag(op(:,n))'; %Eq.(20)
		w_hat = w_hat + Alpha(j) * cos(kk' * MuTmp) .* exp(diag(-.5 * kk' * SigmaTmp * kk)); %Eq.(21)
	end
end
w_hat = w_hat / L^nbVar / size(op,2);

% %Alternative computation of w_hat by discretization
% nbRes = 100;
% xm1d = linspace(xlim(1), xlim(2), nbRes); %Spatial range for 1D
% [xm(1,:,:), xm(2,:,:)] = ndgrid(xm1d, xm1d); %Spatial range
% g = zeros(1,nbRes^nbVar);
% for k=1:nbStates
% 	g = g + Priors(k) * mvnpdf(xm(:,:)', Mu(:,k)', Sigma(:,:,k))'; %Spatial distribution
% end
% phi_inv = cos(KX(1,:)' * xm(1,:) * om) .* cos(KX(2,:)' * xm(2,:) * om) / L^nbVar / nbRes^nbVar;
% w_hat = phi_inv * g'; %Fourier coefficients of spatial distribution

%Fourier basis functions (for a discretized map)
xm1d = linspace(xlim(1), xlim(2), nbRes); %Spatial range for 1D
[xm(1,:,:), xm(2,:,:)] = ndgrid(xm1d, xm1d); %Spatial range
phim = cos(KX(1,:)' * xm(1,:) .* om) .* cos(KX(2,:)' * xm(2,:) * om) * 2^nbVar; %Fourier basis functions

[xx, yy] = ndgrid(1:nbFct, 1:nbFct);
hk = [1; 2*ones(nbFct-1,1)];
HK = hk(xx(:)) .* hk(yy(:)); 
phim = phim .* repmat(HK,[1,nbRes^nbVar]);

%Desired spatial distribution 
g = w_hat' * phim;


%% Ergodic control 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
x = [.1; .3]; %Initial position
wt = zeros(nbFct^nbVar, 1);
for t=1:nbData
	r.x(:,t) = x; %Log data
	
	%Fourier basis functions and derivatives for each dimension (only cosine part on [0,L/2] is computed since the signal is even and real by construction) 
	phi1 = cos(x * rg * om); %Eq.(18)
	dphi1 = -sin(x * rg * om) .* repmat(rg,nbVar,1) * om;
	
	dphi = [dphi1(1,xx) .* phi1(2,yy); phi1(1,xx) .* dphi1(2,yy)]; %Gradient of basis functions
	wt = wt + (phi1(1,xx) .* phi1(2,yy))' / L^nbVar;	%wt./t are the Fourier series coefficients along trajectory (Eq.(17))

	%Controller with constrained velocity norm
	u = -dphi * (Lambda .* (wt/t - w_hat)); %Eq.(24)
	u = u * u_max / (norm(u)+1E-1); %Velocity command
	
	x = x + u * dt; %Update of position
	r.g(:,t) = (wt/t)' * phim; %Reconstructed spatial distribution (for visualization)
	r.w(:,t) = wt/t; %Fourier coefficients along trajectory (for visualization)
% 	r.e(t) = sum(sum((wt./t - w_hat).^2 .* Lambda)); %Reconstruction error evaluation
end

% Plot 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
h = figure('position',[10,10,1800,600]); 
colormap(repmat(linspace(1,.4,64),3,1)');

%x
subplot(1,3,1); hold on; axis off; title('Path generated by ergodic control','fontsize',20);
G = reshape(g,[nbRes,nbRes]); % original spatial distribution
% G = reshape(r.g(:,end),[nbRes,nbRes]); % reconstructed spatial distribution
G([1,end],:) = max(g); %Add vertical image borders
G(:,[1,end]) = max(g); %Add horizontal image borders
surface(squeeze(xm(1,:,:)), squeeze(xm(2,:,:)), zeros([nbRes,nbRes]), G, 'FaceColor','interp','EdgeColor','interp');
% surface(squeeze(xm(1,:,:)), squeeze(xm(2,:,:)), zeros([nbRes,nbRes]), reshape(r.g(:,end),[nbRes,nbRes]), 'FaceColor','interp','EdgeColor','interp');
plot(r.x(1,:), r.x(2,:), '-','linewidth',1,'color',[0 0 0]);
plot(r.x(1,1), r.x(2,1), '.','markersize',15,'color',[0 0 0]);
axis([xlim(1),xlim(2),xlim(1),xlim(2)]); axis equal;

%w
subplot(1,3,2); hold on; axis off; title('Reproduced weights','fontsize',20);
imagesc(reshape(wt./t,[nbFct,nbFct]));
axis tight; axis equal; axis ij;

%w_hat
subplot(1,3,3); hold on; axis off; title('Desired weights','fontsize',20);
imagesc(reshape(w_hat,nbFct,nbFct));
axis tight; axis equal; axis ij;

waitfor(h);
close all;
